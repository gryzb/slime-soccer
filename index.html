<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>Slime Soccer</title>
  <script src="https://telegram.org/js/telegram-web-app.js?59"></script>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    html, body {
      width: 100%; height: 100%;
      overflow: hidden;
      background: #000;
      touch-action: none;
      -webkit-touch-callout: none;
      -webkit-user-select: none;
      user-select: none;
    }
    #gameCanvas {
      display: block;
      width: 100vw;
      height: 100vh;
      touch-action: none;
    }
  </style>
</head>
<body>
  <canvas id="gameCanvas"></canvas>
  <script>
  'use strict';

  // ============================================================
  // SECTION 1: CONSTANTS & CONFIGURATION
  // ============================================================
  const CONFIG = {
    DESIGN_WIDTH: 800,
    DESIGN_HEIGHT: 500,
    GROUND_Y: 420,

    GRAVITY: 0.45,
    BALL_BOUNCE: 0.65,
    SLIME_BOUNCE: 1.05,
    MAX_BALL_SPEED: 14,
    BALL_RADIUS: 14,
    SLIME_RADIUS: 45,

    SLIME_SPEED: 5,
    SLIME_JUMP_VEL: -11,
    GROUND_FRICTION: 0.82,
    AIR_FRICTION: 0.97,

    GOAL_POST_W: 8,
    GOAL_HEIGHT: 120,
    GOAL_DEPTH: 55,
    NET_SPACING: 15,

    GRAB_RANGE: 8,
    GRAB_THROW_SPEED: 13,
    GRAB_MAX_HOLD: 90,

    CAMP_WARN_FRAMES: 180,
    CAMP_PENALTY_FRAMES: 300,
    CAMP_ZONE_W: 75,

    DURATIONS: [1, 2, 3, 5, 8],
    CELEBRATION_FRAMES: 120,

    COL_SKY_TOP: '#1a5276',
    COL_SKY_BOT: '#2e86c1',
    COL_GROUND: '#616a6b',
    COL_GROUND_LINE: '#4d5656',
    COL_P1: '#00e5ff',
    COL_P2: '#ff1744',
    COL_BALL: '#fdd835',
    COL_BALL_LINE: '#fff9c4',
    COL_POST: '#ecf0f1',
    COL_NET: 'rgba(255,255,255,0.25)',
    COL_TEXT: '#ffffff',
    COL_WARN: '#ff6f00',
    COL_MENU_BG: '#0d1b2a',
    COL_MENU_BTN: '#1b2838',
    COL_MENU_ACCENT: '#00e5ff',

    GOAL_PARTICLES: 35,
    HIT_PARTICLES: 6,

    AI_REACT_DELAY: 6,
    AI_ACCURACY: 0.88,
    AI_JUMP_THRESH: 50,

    // Network
    WS_URL: 'https://fresh-donkey-36.gryzb.deno.net',
    NET_STATE_INTERVAL: 3,
    NET_LERP: 0.25,
  };

  // ============================================================
  // SECTION 2: TELEGRAM INTEGRATION
  // ============================================================
  const TG = {
    wa: null, ok: false,
    init() {
      try {
        if (window.Telegram && window.Telegram.WebApp) {
          this.wa = window.Telegram.WebApp;
          this.ok = true;
          this.wa.ready();
          this.wa.expand();
          if (this.wa.requestFullscreen) this.wa.requestFullscreen();
          if (this.wa.disableVerticalSwipes) this.wa.disableVerticalSwipes();
        }
      } catch (e) { this.ok = false; }
    },
    haptic(type, val) {
      if (!this.ok || !this.wa.HapticFeedback) return;
      try {
        if (type === 'impact') this.wa.HapticFeedback.impactOccurred(val || 'medium');
        else if (type === 'notify') this.wa.HapticFeedback.notificationOccurred(val || 'success');
        else if (type === 'select') this.wa.HapticFeedback.selectionChanged();
      } catch (e) {}
    }
  };

  // ============================================================
  // SECTION 3: INPUT MANAGER
  // ============================================================
  const Input = {
    p1: { left: false, right: false, jump: false, grab: false },
    p2: { left: false, right: false, jump: false, grab: false },
    keys: {},
    isMobile: false,
    touch: {
      joy: { active: false, id: null, cx: 0, cy: 0, dx: 0, dy: 0, r: 65 },
      btnJump: { active: false, id: null },
      btnGrab: { active: false, id: null },
    },
    canvas: null,

    init(canvas) {
      this.canvas = canvas;
      this.isMobile = 'ontouchstart' in window || navigator.maxTouchPoints > 0;
      window.addEventListener('keydown', e => { this.keys[e.code] = true; e.preventDefault(); });
      window.addEventListener('keyup', e => { this.keys[e.code] = false; });
      canvas.addEventListener('touchstart', e => this.onTS(e), { passive: false });
      canvas.addEventListener('touchmove', e => this.onTM(e), { passive: false });
      canvas.addEventListener('touchend', e => this.onTE(e), { passive: false });
      canvas.addEventListener('touchcancel', e => this.onTE(e), { passive: false });
      document.addEventListener('touchmove', e => e.preventDefault(), { passive: false });
    },

    s2c(tx, ty) {
      const r = this.canvas.getBoundingClientRect();
      return { x: tx - r.left, y: ty - r.top };
    },

    jbRect() {
      const cw = this.canvas.clientWidth, ch = this.canvas.clientHeight;
      const sz = Math.min(cw, ch) * 0.13;
      return { x: cw - sz * 1.5, y: ch - sz * 2.8, r: sz * 0.48 };
    },

    gbRect() {
      const cw = this.canvas.clientWidth, ch = this.canvas.clientHeight;
      const sz = Math.min(cw, ch) * 0.13;
      return { x: cw - sz * 1.5, y: ch - sz * 1.2, r: sz * 0.42 };
    },

    inC(px, py, cx, cy, cr) {
      return (px - cx) ** 2 + (py - cy) ** 2 <= cr * cr;
    },

    onTS(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        const p = this.s2c(t.clientX, t.clientY);
        const jb = this.jbRect(), gb = this.gbRect();
        if (this.inC(p.x, p.y, jb.x, jb.y, jb.r * 1.5)) {
          this.touch.btnJump = { active: true, id: t.identifier };
        } else if (this.inC(p.x, p.y, gb.x, gb.y, gb.r * 1.5)) {
          this.touch.btnGrab = { active: true, id: t.identifier };
        } else if (p.x < this.canvas.clientWidth * 0.5) {
          this.touch.joy = { active: true, id: t.identifier, cx: p.x, cy: p.y, dx: 0, dy: 0, r: this.touch.joy.r };
        }
      }
    },

    onTM(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (this.touch.joy.active && t.identifier === this.touch.joy.id) {
          const p = this.s2c(t.clientX, t.clientY);
          this.touch.joy.dx = p.x - this.touch.joy.cx;
          this.touch.joy.dy = p.y - this.touch.joy.cy;
        }
      }
    },

    onTE(e) {
      e.preventDefault();
      for (let i = 0; i < e.changedTouches.length; i++) {
        const t = e.changedTouches[i];
        if (this.touch.joy.active && t.identifier === this.touch.joy.id) {
          this.touch.joy.active = false; this.touch.joy.dx = 0; this.touch.joy.dy = 0;
        }
        if (this.touch.btnJump.active && t.identifier === this.touch.btnJump.id) this.touch.btnJump.active = false;
        if (this.touch.btnGrab.active && t.identifier === this.touch.btnGrab.id) this.touch.btnGrab.active = false;
      }
    },

    update() {
      this.p1.left = !!this.keys['ArrowLeft'];
      this.p1.right = !!this.keys['ArrowRight'];
      this.p1.jump = !!this.keys['ArrowUp'];
      this.p1.grab = !!this.keys['ArrowDown'];

      if (this.isMobile) {
        const j = this.touch.joy;
        if (j.active) {
          const mag = Math.sqrt(j.dx * j.dx + j.dy * j.dy);
          if (mag > 18) {
            const nx = j.dx / mag;
            this.p1.left = nx < -0.35;
            this.p1.right = nx > 0.35;
            if (j.dy / mag < -0.5) this.p1.jump = true;
          }
        }
        if (this.touch.btnJump.active) this.p1.jump = true;
        if (this.touch.btnGrab.active) this.p1.grab = true;
      }

      this.p2.left = !!this.keys['KeyA'];
      this.p2.right = !!this.keys['KeyD'];
      this.p2.jump = !!this.keys['KeyW'];
      this.p2.grab = !!this.keys['KeyS'];
    },

    renderTouch(ctx, cw, ch) {
      if (!this.isMobile) return;
      ctx.save();
      const j = this.touch.joy;
      if (j.active) {
        ctx.beginPath(); ctx.arc(j.cx, j.cy, j.r, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.1)'; ctx.fill();
        ctx.strokeStyle = 'rgba(255,255,255,0.3)'; ctx.lineWidth = 2; ctx.stroke();
        const mag = Math.sqrt(j.dx * j.dx + j.dy * j.dy);
        const cl = Math.min(mag, j.r);
        const tx = mag > 0 ? j.cx + (j.dx / mag) * cl : j.cx;
        const ty = mag > 0 ? j.cy + (j.dy / mag) * cl : j.cy;
        ctx.beginPath(); ctx.arc(tx, ty, 22, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(255,255,255,0.35)'; ctx.fill();
      } else {
        const hx = cw * 0.15, hy = ch * 0.65;
        ctx.beginPath(); ctx.arc(hx, hy, j.r, 0, Math.PI * 2);
        ctx.strokeStyle = 'rgba(255,255,255,0.15)'; ctx.lineWidth = 2;
        ctx.setLineDash([8, 8]); ctx.stroke(); ctx.setLineDash([]);
        ctx.fillStyle = 'rgba(255,255,255,0.15)'; ctx.font = '14px monospace';
        ctx.textAlign = 'center'; ctx.fillText('MOVE', hx, hy + 5);
      }
      const jb = this.jbRect();
      ctx.beginPath(); ctx.arc(jb.x, jb.y, jb.r, 0, Math.PI * 2);
      ctx.fillStyle = this.touch.btnJump.active ? 'rgba(0,229,255,0.4)' : 'rgba(255,255,255,0.12)'; ctx.fill();
      ctx.strokeStyle = 'rgba(0,229,255,0.5)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = 'bold 14px monospace';
      ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText('JUMP', jb.x, jb.y);

      const gb = this.gbRect();
      ctx.beginPath(); ctx.arc(gb.x, gb.y, gb.r, 0, Math.PI * 2);
      ctx.fillStyle = this.touch.btnGrab.active ? 'rgba(255,23,68,0.4)' : 'rgba(255,255,255,0.12)'; ctx.fill();
      ctx.strokeStyle = 'rgba(255,23,68,0.5)'; ctx.lineWidth = 2; ctx.stroke();
      ctx.fillStyle = 'rgba(255,255,255,0.7)'; ctx.font = 'bold 13px monospace';
      ctx.fillText('GRAB', gb.x, gb.y);
      ctx.restore();
    }
  };

  // ============================================================
  // SECTION 4: PHYSICS ENGINE
  // ============================================================
  const Physics = {
    circlesOverlap(x1, y1, r1, x2, y2, r2) {
      const dx = x2 - x1, dy = y2 - y1;
      return dx * dx + dy * dy <= (r1 + r2) * (r1 + r2);
    },

    ballTouchesSlime(ball, slime) {
      if (!this.circlesOverlap(ball.x, ball.y, ball.radius, slime.x, slime.y, slime.radius)) return false;
      return ball.y <= slime.y + ball.radius * 0.3;
    },

    resolveBallSlime(ball, slime) {
      const dx = ball.x - slime.x, dy = ball.y - slime.y;
      const dist = Math.sqrt(dx * dx + dy * dy);
      if (dist === 0) return;
      const nx = dx / dist, ny = dy / dist;
      const dvx = ball.vx - slime.vx, dvy = ball.vy - slime.vy;
      const dvn = dvx * nx + dvy * ny;
      if (dvn > 0) return;
      const imp = -(1 + CONFIG.SLIME_BOUNCE) * dvn;
      ball.vx += imp * nx + slime.vx * 0.35;
      ball.vy += imp * ny + slime.vy * 0.25;
      const overlap = (ball.radius + slime.radius) - dist;
      if (overlap > 0) { ball.x += nx * (overlap + 1); ball.y += ny * (overlap + 1); }
      this.clampBall(ball);
    },

    clampBall(ball) {
      const sp = Math.sqrt(ball.vx * ball.vx + ball.vy * ball.vy);
      if (sp > CONFIG.MAX_BALL_SPEED) {
        ball.vx = (ball.vx / sp) * CONFIG.MAX_BALL_SPEED;
        ball.vy = (ball.vy / sp) * CONFIG.MAX_BALL_SPEED;
      }
    },

    resolveBallWalls(ball, fw, groundY) {
      const goalTop = groundY - CONFIG.GOAL_HEIGHT;
      if (ball.y + ball.radius >= groundY) {
        ball.y = groundY - ball.radius;
        ball.vy = -Math.abs(ball.vy) * CONFIG.BALL_BOUNCE;
        ball.vx *= 0.97;
        if (Math.abs(ball.vy) < 0.5) ball.vy = 0;
      }
      if (ball.y - ball.radius <= 0) { ball.y = ball.radius; ball.vy = Math.abs(ball.vy) * CONFIG.BALL_BOUNCE; }

      // Left side
      if (ball.y - ball.radius < goalTop || ball.y > groundY) {
        if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx = Math.abs(ball.vx) * CONFIG.BALL_BOUNCE; }
      } else {
        // In goal height range
        if (ball.x - ball.radius < 0) { ball.x = ball.radius; ball.vx = Math.abs(ball.vx) * CONFIG.BALL_BOUNCE; }
        // Post
        if (ball.x + ball.radius > CONFIG.GOAL_DEPTH && ball.x - ball.radius < CONFIG.GOAL_DEPTH + CONFIG.GOAL_POST_W && ball.y > goalTop) {
          if (ball.vx < 0) ball.x = CONFIG.GOAL_DEPTH + CONFIG.GOAL_POST_W + ball.radius;
          ball.vx = Math.abs(ball.vx) * CONFIG.BALL_BOUNCE;
        }
      }
      // Crossbar left
      if (ball.x < CONFIG.GOAL_DEPTH + CONFIG.GOAL_POST_W && ball.y + ball.radius > goalTop - CONFIG.GOAL_POST_W && ball.y - ball.radius < goalTop && ball.vy > 0) {
        ball.y = goalTop - CONFIG.GOAL_POST_W - ball.radius;
        ball.vy = -Math.abs(ball.vy) * CONFIG.BALL_BOUNCE;
      }

      // Right side
      const rPost = fw - CONFIG.GOAL_DEPTH - CONFIG.GOAL_POST_W;
      if (ball.y - ball.radius < goalTop || ball.y > groundY) {
        if (ball.x + ball.radius > fw) { ball.x = fw - ball.radius; ball.vx = -Math.abs(ball.vx) * CONFIG.BALL_BOUNCE; }
      } else {
        if (ball.x + ball.radius > fw) { ball.x = fw - ball.radius; ball.vx = -Math.abs(ball.vx) * CONFIG.BALL_BOUNCE; }
        if (ball.x - ball.radius < rPost + CONFIG.GOAL_POST_W && ball.x + ball.radius > rPost && ball.y > goalTop) {
          if (ball.vx > 0) ball.x = rPost - ball.radius;
          ball.vx = -Math.abs(ball.vx) * CONFIG.BALL_BOUNCE;
        }
      }
      // Crossbar right
      if (ball.x > rPost && ball.y + ball.radius > goalTop - CONFIG.GOAL_POST_W && ball.y - ball.radius < goalTop && ball.vy > 0) {
        ball.y = goalTop - CONFIG.GOAL_POST_W - ball.radius;
        ball.vy = -Math.abs(ball.vy) * CONFIG.BALL_BOUNCE;
      }
    },

    ballInGoal(ball, side, fw) {
      const goalTop = CONFIG.GROUND_Y - CONFIG.GOAL_HEIGHT;
      const inY = ball.y > goalTop && ball.y < CONFIG.GROUND_Y;
      if (side === 'left') return ball.x - ball.radius <= CONFIG.GOAL_POST_W && inY;
      return ball.x + ball.radius >= fw - CONFIG.GOAL_POST_W && inY;
    }
  };

  // ============================================================
  // SECTION 5: ENTITIES
  // ============================================================
  class Slime {
    constructor(num, x, color) {
      this.num = num; this.x = x; this.y = CONFIG.GROUND_Y;
      this.vx = 0; this.vy = 0; this.radius = CONFIG.SLIME_RADIUS;
      this.color = color; this.score = 0; this.onGround = true;
      this.grabTimer = 0; this.campTimer = 0; this.campWarn = false;
    }
    update(input) {
      if (input.left) this.vx = -CONFIG.SLIME_SPEED;
      else if (input.right) this.vx = CONFIG.SLIME_SPEED;
      else this.vx *= (this.onGround ? CONFIG.GROUND_FRICTION : CONFIG.AIR_FRICTION);
      if (input.jump && this.onGround) { this.vy = CONFIG.SLIME_JUMP_VEL; this.onGround = false; }
      this.vy += CONFIG.GRAVITY;
      this.x += this.vx; this.y += this.vy;
      if (this.y >= CONFIG.GROUND_Y) { this.y = CONFIG.GROUND_Y; this.vy = 0; this.onGround = true; }
      const goalTop = CONFIG.GROUND_Y - CONFIG.GOAL_HEIGHT;
      const lb = this.y > goalTop ? 0 : CONFIG.GOAL_DEPTH + CONFIG.GOAL_POST_W;
      const rb = this.y > goalTop ? CONFIG.DESIGN_WIDTH : CONFIG.DESIGN_WIDTH - CONFIG.GOAL_DEPTH - CONFIG.GOAL_POST_W;
      this.x = Math.max(lb + this.radius, Math.min(rb - this.radius, this.x));
      if (Math.abs(this.vx) < 0.1) this.vx = 0;
    }
  }

  class Ball {
    constructor(x, y) {
      this.x = x; this.y = y; this.vx = 0; this.vy = 0;
      this.radius = CONFIG.BALL_RADIUS; this.rot = 0;
      this.grabbed = false; this.grabbedBy = null; this.grabAngle = Math.PI / 2;
    }
    update() {
      if (this.grabbed && this.grabbedBy) {
        const s = this.grabbedBy;
        this.x = s.x + Math.cos(this.grabAngle) * (s.radius + this.radius + 2);
        this.y = s.y - Math.abs(Math.sin(this.grabAngle)) * (s.radius + this.radius + 2);
        this.vx = 0; this.vy = 0; return;
      }
      this.vy += CONFIG.GRAVITY; this.x += this.vx; this.y += this.vy;
      this.rot += this.vx * 0.06;
    }
    doThrow() {
      this.vx = Math.cos(this.grabAngle) * CONFIG.GRAB_THROW_SPEED;
      this.vy = -Math.abs(Math.sin(this.grabAngle)) * CONFIG.GRAB_THROW_SPEED;
      this.grabbed = false; this.grabbedBy = null;
    }
  }

  class Particle {
    constructor(x, y, color) {
      this.x = x; this.y = y;
      this.vx = (Math.random() - 0.5) * 10; this.vy = (Math.random() - 0.5) * 10 - 4;
      this.life = 1; this.decay = 0.015 + Math.random() * 0.025;
      this.r = 2 + Math.random() * 5; this.color = color;
    }
    update() { this.vy += CONFIG.GRAVITY * 0.25; this.x += this.vx; this.y += this.vy; this.life -= this.decay; }
    get alive() { return this.life > 0; }
  }

  // ============================================================
  // SECTION 6: AI CONTROLLER
  // ============================================================
  const AI = {
    timer: 0, targetX: 0, doJump: false, doGrab: false,
    throwRelease: false, aimLeft: false, aimRight: false,

    update(slime, ball, opp, fw) {
      this.timer++;
      if (this.timer >= CONFIG.AI_REACT_DELAY) { this.timer = 0; this.think(slime, ball, opp, fw); }
      const input = { left: false, right: false, jump: false, grab: false };
      const dx = this.targetX - slime.x;
      if (Math.abs(dx) > 12) { input.left = dx < 0; input.right = dx > 0; }
      input.jump = this.doJump && slime.onGround;
      input.grab = this.doGrab;
      if (Math.random() > CONFIG.AI_ACCURACY) { input.left = false; input.right = false; }
      if (this.throwRelease) { input.grab = false; this.throwRelease = false; this.aimLeft = false; this.aimRight = false; }
      if (this.aimLeft) { input.left = true; input.right = false; }
      if (this.aimRight) { input.right = true; input.left = false; }
      return input;
    },

    think(slime, ball, opp, fw) {
      const mid = fw / 2;
      if (ball.grabbed && ball.grabbedBy === slime) {
        const desired = Math.PI * 0.7;
        if (Math.abs(ball.grabAngle - desired) > 0.2) {
          this.doGrab = true; this.throwRelease = false;
          this.aimLeft = ball.grabAngle < desired;
          this.aimRight = ball.grabAngle > desired;
        } else {
          this.doGrab = false; this.throwRelease = true; this.aimLeft = false; this.aimRight = false;
        }
        this.targetX = slime.x; return;
      }
      const onMySide = ball.x > mid, approaching = ball.vx > 1;
      if (onMySide || (approaching && ball.x > mid * 0.5)) {
        this.targetX = Math.max(mid, Math.min(fw - slime.radius - 10, ball.x + ball.vx * 8));
        const predY = ball.y + ball.vy * 6;
        const dist = Math.sqrt((ball.x - slime.x) ** 2 + (ball.y - slime.y) ** 2);
        this.doJump = predY < slime.y - CONFIG.AI_JUMP_THRESH && dist < 200;
        this.doGrab = dist < slime.radius + ball.radius + CONFIG.GRAB_RANGE + 30 && ball.y < slime.y;
      } else {
        this.targetX = fw * 0.73; this.doJump = false; this.doGrab = false;
      }
    }
  };

  // ============================================================
  // SECTION 7: ANTI-CAMPING
  // ============================================================
  const Camping = {
    update(slime, fw) {
      const inZone = slime.num === 1
        ? slime.x - slime.radius < CONFIG.CAMP_ZONE_W
        : slime.x + slime.radius > fw - CONFIG.CAMP_ZONE_W;
      if (inZone) {
        slime.campTimer++;
        slime.campWarn = slime.campTimer >= CONFIG.CAMP_WARN_FRAMES;
        if (slime.campTimer >= CONFIG.CAMP_PENALTY_FRAMES) {
          slime.campTimer = 0; slime.campWarn = false; return true;
        }
      } else { slime.campTimer = Math.max(0, slime.campTimer - 2); slime.campWarn = false; }
      return false;
    }
  };

  // ============================================================
  // SECTION 8: NETWORK MODULE
  // ============================================================
  const Net = {
    ws: null, isHost: false, isOnline: false, roomId: null,
    connected: false, oppConnected: false,
    lastOppInput: { left: false, right: false, jump: false, grab: false },
    target: null, disconnectCb: null, oppJoinCb: null, startCb: null,

    connect(roomId) {
      this.roomId = roomId; this.isOnline = true;
      this.connected = false; this.oppConnected = false; this.target = null;
      try { this.ws = new WebSocket(CONFIG.WS_URL + '?room=' + encodeURIComponent(roomId)); } catch (e) { return; }

      this.ws.onopen = () => { this.connected = true; };
      this.ws.onmessage = (e) => {
        let msg; try { msg = JSON.parse(e.data); } catch { return; }
        switch (msg.type) {
          case 'role': this.isHost = msg.role === 'host'; break;
          case 'joined': this.oppConnected = true; if (this.oppJoinCb) this.oppJoinCb(); break;
          case 'left': this.oppConnected = false; if (this.disconnectCb) this.disconnectCb(); break;
          case 'input':
            if (msg.d) this.lastOppInput = { left: !!msg.d.l, right: !!msg.d.r, jump: !!msg.d.j, grab: !!msg.d.g };
            break;
          case 'state': if (msg.d) this.target = msg.d; break;
          case 'start': if (this.startCb) this.startCb(msg.dur); break;
        }
      };
      this.ws.onclose = () => { this.connected = false; if (this.isOnline && this.disconnectCb) this.disconnectCb(); };
      this.ws.onerror = () => {};
    },

    sendInput(input) {
      if (!this.ws || this.ws.readyState !== 1) return;
      this.ws.send(JSON.stringify({ type: 'input', d: { l: input.left, r: input.right, j: input.jump, g: input.grab } }));
    },

    sendState(game) {
      if (!this.ws || this.ws.readyState !== 1) return;
      const s1 = game.s1, s2 = game.s2, b = game.ball;
      const rnd = (v) => Math.round(v * 10) / 10;
      this.ws.send(JSON.stringify({ type: 'state', d: {
        s1x: rnd(s1.x), s1y: rnd(s1.y), s1vx: rnd(s1.vx), s1vy: rnd(s1.vy),
        s2x: rnd(s2.x), s2y: rnd(s2.y), s2vx: rnd(s2.vx), s2vy: rnd(s2.vy),
        bx: rnd(b.x), by: rnd(b.y), bvx: rnd(b.vx), bvy: rnd(b.vy),
        br: Math.round(b.rot * 100) / 100,
        bg: b.grabbed ? 1 : 0, bga: Math.round(b.grabAngle * 100) / 100,
        sc1: s1.score, sc2: s2.score, tl: game.timeLeft,
        st: game.state === 'PLAYING' ? 0 : game.state === 'GOAL_SCORED' ? 1 : 2,
        ct: game.celebTimer, ls: game.lastScorer
      }}));
    },

    sendStart(dur) {
      if (!this.ws || this.ws.readyState !== 1) return;
      this.ws.send(JSON.stringify({ type: 'start', dur: dur }));
    },

    applyState(game) {
      const t = this.target; if (!t) return;
      const L = CONFIG.NET_LERP;
      game.s1.x += (t.s1x - game.s1.x) * L; game.s1.y += (t.s1y - game.s1.y) * L;
      game.s1.vx = t.s1vx; game.s1.vy = t.s1vy; game.s1.score = t.sc1;
      game.s2.x += (t.s2x - game.s2.x) * L; game.s2.y += (t.s2y - game.s2.y) * L;
      game.s2.vx = t.s2vx; game.s2.vy = t.s2vy; game.s2.score = t.sc2;
      game.ball.x += (t.bx - game.ball.x) * (L + 0.1); game.ball.y += (t.by - game.ball.y) * (L + 0.1);
      game.ball.vx = t.bvx; game.ball.vy = t.bvy; game.ball.rot = t.br;
      game.ball.grabbed = t.bg === 1; game.ball.grabAngle = t.bga;
      if (game.ball.grabbed) game.ball.grabbedBy = t.bga < Math.PI / 2 ? game.s2 : game.s1;
      game.timeLeft = t.tl; game.lastScorer = t.ls; game.celebTimer = t.ct;
      const sm = { 0: 'PLAYING', 1: 'GOAL_SCORED', 2: 'GAME_OVER' };
      const ns = sm[t.st];
      if (ns && ns !== game.state && game.state !== 'MENU') {
        if (ns === 'GOAL_SCORED' && game.state === 'PLAYING') {
          TG.haptic('notify', 'success'); Render.doShake(18);
          const gx = t.ls === 1 ? CONFIG.GOAL_DEPTH : CONFIG.DESIGN_WIDTH - CONFIG.GOAL_DEPTH;
          const gy = CONFIG.GROUND_Y - CONFIG.GOAL_HEIGHT / 2;
          for (let i = 0; i < CONFIG.GOAL_PARTICLES; i++) game.particles.push(new Particle(gx, gy, t.ls === 1 ? CONFIG.COL_P1 : CONFIG.COL_P2));
        }
        if (ns === 'GAME_OVER') { TG.haptic('notify', 'error'); game.gameOverTimer = 0; }
        game.state = ns;
      }
    },

    disconnect() {
      this.isOnline = false; this.oppConnected = false; this.connected = false; this.target = null;
      if (this.ws) { this.ws.close(); this.ws = null; }
    },

    genRoomId() {
      if (TG.ok && TG.wa.initDataUnsafe && TG.wa.initDataUnsafe.chat_instance) return 'tg_' + TG.wa.initDataUnsafe.chat_instance;
      const ch = 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; let id = '';
      for (let i = 0; i < 6; i++) id += ch[Math.floor(Math.random() * ch.length)];
      return id;
    }
  };

  // ============================================================
  // SECTION 9: RENDERER
  // ============================================================
  const Render = {
    canvas: null, ctx: null, scale: 1, ox: 0, oy: 0,
    shake: { x: 0, y: 0, int: 0 },

    init(canvas) { this.canvas = canvas; this.ctx = canvas.getContext('2d'); this.resize(); },

    resize() {
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      this.canvas.width = window.innerWidth * dpr; this.canvas.height = window.innerHeight * dpr;
      this.scale = Math.min(this.canvas.width / CONFIG.DESIGN_WIDTH, this.canvas.height / CONFIG.DESIGN_HEIGHT);
      this.ox = (this.canvas.width - CONFIG.DESIGN_WIDTH * this.scale) / 2;
      this.oy = (this.canvas.height - CONFIG.DESIGN_HEIGHT * this.scale) / 2;
    },

    begin() {
      const c = this.ctx; c.save();
      c.fillStyle = '#000'; c.fillRect(0, 0, this.canvas.width, this.canvas.height);
      c.translate(this.ox + this.shake.x, this.oy + this.shake.y);
      c.scale(this.scale, this.scale);
    },

    end() {
      this.ctx.restore();
      this.shake.int *= 0.88;
      if (this.shake.int < 0.5) { this.shake.x = 0; this.shake.y = 0; }
      else { this.shake.x = (Math.random() - 0.5) * this.shake.int; this.shake.y = (Math.random() - 0.5) * this.shake.int; }
    },

    doShake(i) { this.shake.int = i; },

    drawBG() {
      const c = this.ctx;
      const g = c.createLinearGradient(0, 0, 0, CONFIG.GROUND_Y);
      g.addColorStop(0, CONFIG.COL_SKY_TOP); g.addColorStop(1, CONFIG.COL_SKY_BOT);
      c.fillStyle = g; c.fillRect(0, 0, CONFIG.DESIGN_WIDTH, CONFIG.GROUND_Y);
      c.fillStyle = CONFIG.COL_GROUND; c.fillRect(0, CONFIG.GROUND_Y, CONFIG.DESIGN_WIDTH, CONFIG.DESIGN_HEIGHT - CONFIG.GROUND_Y);
      c.strokeStyle = CONFIG.COL_GROUND_LINE; c.lineWidth = 3;
      c.beginPath(); c.moveTo(0, CONFIG.GROUND_Y); c.lineTo(CONFIG.DESIGN_WIDTH, CONFIG.GROUND_Y); c.stroke();
      c.strokeStyle = 'rgba(255,255,255,0.1)'; c.lineWidth = 2; c.setLineDash([10, 10]);
      c.beginPath(); c.moveTo(CONFIG.DESIGN_WIDTH / 2, 0); c.lineTo(CONFIG.DESIGN_WIDTH / 2, CONFIG.GROUND_Y); c.stroke();
      c.setLineDash([]);
    },

    drawGoals() {
      const c = this.ctx, fw = CONFIG.DESIGN_WIDTH, gy = CONFIG.GROUND_Y;
      const gh = CONFIG.GOAL_HEIGHT, gd = CONFIG.GOAL_DEPTH, pw = CONFIG.GOAL_POST_W, ns = CONFIG.NET_SPACING;
      const gt = gy - gh;
      c.strokeStyle = CONFIG.COL_NET; c.lineWidth = 1;
      for (let y = gt; y <= gy; y += ns) { c.beginPath(); c.moveTo(0, y); c.lineTo(gd, y); c.stroke(); }
      for (let x = 0; x <= gd; x += ns) { c.beginPath(); c.moveTo(x, gt); c.lineTo(x, gy); c.stroke(); }
      c.fillStyle = CONFIG.COL_POST;
      c.fillRect(gd, gt - pw, pw, gh + pw); c.fillRect(0, gt - pw, gd + pw, pw);
      const rx = fw - gd;
      for (let y = gt; y <= gy; y += ns) { c.beginPath(); c.moveTo(rx, y); c.lineTo(fw, y); c.stroke(); }
      for (let x = rx; x <= fw; x += ns) { c.beginPath(); c.moveTo(x, gt); c.lineTo(x, gy); c.stroke(); }
      c.fillStyle = CONFIG.COL_POST;
      c.fillRect(rx - pw, gt - pw, pw, gh + pw); c.fillRect(rx - pw, gt - pw, gd + pw, pw);
    },

    drawSlime(slime) {
      const c = this.ctx; c.save();
      let col = slime.color;
      if (slime.campWarn && Math.floor(Date.now() / 120) % 2 === 0) col = CONFIG.COL_WARN;
      c.fillStyle = 'rgba(0,0,0,0.15)'; c.beginPath();
      c.ellipse(slime.x, CONFIG.GROUND_Y + 3, slime.radius * 0.85, 6, 0, 0, Math.PI * 2); c.fill();
      c.fillStyle = col; c.beginPath(); c.arc(slime.x, slime.y, slime.radius, Math.PI, 0); c.closePath(); c.fill();
      c.fillStyle = 'rgba(255,255,255,0.15)'; c.beginPath();
      c.arc(slime.x - slime.radius * 0.2, slime.y - slime.radius * 0.4, slime.radius * 0.35, 0, Math.PI * 2); c.fill();
      const ed = slime.num === 1 ? 1 : -1;
      const ex = slime.x + slime.radius * 0.3 * ed, ey = slime.y - slime.radius * 0.5;
      c.fillStyle = '#fff'; c.beginPath(); c.arc(ex, ey, 7, 0, Math.PI * 2); c.fill();
      c.fillStyle = '#111'; c.beginPath(); c.arc(ex + 2 * ed, ey + 1, 3.5, 0, Math.PI * 2); c.fill();
      c.restore();
    },

    drawBall(ball) {
      const c = this.ctx; c.save();
      c.fillStyle = 'rgba(0,0,0,0.12)'; c.beginPath();
      c.ellipse(ball.x, CONFIG.GROUND_Y + 3, ball.radius * 0.7, 4, 0, 0, Math.PI * 2); c.fill();
      c.translate(ball.x, ball.y); c.rotate(ball.rot);
      c.fillStyle = CONFIG.COL_BALL; c.beginPath(); c.arc(0, 0, ball.radius, 0, Math.PI * 2); c.fill();
      c.strokeStyle = CONFIG.COL_BALL_LINE; c.lineWidth = 2;
      c.beginPath(); c.moveTo(-ball.radius * 0.7, 0); c.lineTo(ball.radius * 0.7, 0); c.stroke();
      c.beginPath(); c.moveTo(0, -ball.radius * 0.7); c.lineTo(0, ball.radius * 0.7); c.stroke();
      c.fillStyle = 'rgba(255,255,255,0.3)'; c.beginPath();
      c.arc(-ball.radius * 0.25, -ball.radius * 0.25, ball.radius * 0.3, 0, Math.PI * 2); c.fill();
      c.restore();
    },

    drawGrabInd(ball) {
      if (!ball.grabbed || !ball.grabbedBy) return;
      const c = this.ctx, a = ball.grabAngle, len = 35;
      const ax = ball.x + Math.cos(a) * len, ay = ball.y - Math.abs(Math.sin(a)) * len;
      c.save(); c.strokeStyle = 'rgba(255,255,255,0.5)'; c.lineWidth = 2; c.setLineDash([4, 4]);
      c.beginPath(); c.moveTo(ball.x, ball.y); c.lineTo(ax, ay); c.stroke(); c.setLineDash([]);
      c.fillStyle = 'rgba(255,255,255,0.6)'; c.beginPath(); c.arc(ax, ay, 4, 0, Math.PI * 2); c.fill();
      c.restore();
    },

    drawHUD(s1, s2, timeLeft) {
      const c = this.ctx, fw = CONFIG.DESIGN_WIDTH;
      c.fillStyle = 'rgba(0,0,0,0.3)'; c.beginPath(); c.roundRect(fw / 2 - 100, 8, 200, 55, 10); c.fill();
      c.font = 'bold 32px monospace'; c.textAlign = 'center'; c.textBaseline = 'top';
      c.fillStyle = CONFIG.COL_P1; c.fillText(String(s1.score), fw / 2 - 40, 14);
      c.fillStyle = CONFIG.COL_TEXT; c.fillText('-', fw / 2, 14);
      c.fillStyle = CONFIG.COL_P2; c.fillText(String(s2.score), fw / 2 + 40, 14);
      const sec = Math.max(0, Math.ceil(timeLeft / 60));
      c.font = '16px monospace'; c.fillStyle = sec <= 10 ? '#ff5252' : 'rgba(255,255,255,0.7)';
      c.fillText(Math.floor(sec / 60) + ':' + String(sec % 60).padStart(2, '0'), fw / 2, 46);
    },

    drawParticles(particles) {
      const c = this.ctx;
      for (const p of particles) {
        c.globalAlpha = Math.max(0, p.life); c.fillStyle = p.color;
        c.beginPath(); c.arc(p.x, p.y, p.r * p.life, 0, Math.PI * 2); c.fill();
      }
      c.globalAlpha = 1;
    },

    drawGoalText(scorer, timer) {
      const c = this.ctx, alpha = Math.min(1, timer / 30);
      const sc = 1 + (1 - timer / CONFIG.CELEBRATION_FRAMES) * 0.5;
      c.save(); c.translate(CONFIG.DESIGN_WIDTH / 2, CONFIG.DESIGN_HEIGHT * 0.35);
      c.scale(sc, sc); c.globalAlpha = alpha;
      c.font = 'bold 64px monospace'; c.textAlign = 'center'; c.textBaseline = 'middle';
      c.fillStyle = scorer === 1 ? CONFIG.COL_P1 : CONFIG.COL_P2;
      c.fillText('GOAL!', 0, 0); c.restore();
    },

    drawGameOver(s1, s2, disconnected) {
      const c = this.ctx, fw = CONFIG.DESIGN_WIDTH, fh = CONFIG.DESIGN_HEIGHT;
      c.fillStyle = 'rgba(0,0,0,0.6)'; c.fillRect(0, 0, fw, fh);
      c.textAlign = 'center'; c.textBaseline = 'middle';
      if (disconnected) {
        c.font = 'bold 48px monospace'; c.fillStyle = CONFIG.COL_WARN;
        c.fillText('DISCONNECTED', fw / 2, fh * 0.3);
        c.font = '20px monospace'; c.fillStyle = 'rgba(255,255,255,0.6)';
        c.fillText('Opponent left the game', fw / 2, fh * 0.45);
        c.fillText('Tap or press Enter', fw / 2, fh * 0.7); return;
      }
      c.font = 'bold 48px monospace';
      let text, color;
      if (s1.score > s2.score) { text = 'PLAYER 1 WINS!'; color = CONFIG.COL_P1; }
      else if (s2.score > s1.score) { text = 'PLAYER 2 WINS!'; color = CONFIG.COL_P2; }
      else { text = 'DRAW!'; color = CONFIG.COL_TEXT; }
      c.fillStyle = color; c.fillText(text, fw / 2, fh * 0.35);
      c.font = 'bold 72px monospace';
      c.fillStyle = CONFIG.COL_P1; c.fillText(String(s1.score), fw / 2 - 60, fh * 0.5);
      c.fillStyle = CONFIG.COL_TEXT; c.fillText('-', fw / 2, fh * 0.5);
      c.fillStyle = CONFIG.COL_P2; c.fillText(String(s2.score), fw / 2 + 60, fh * 0.5);
      c.font = '20px monospace'; c.fillStyle = 'rgba(255,255,255,0.6)';
      c.fillText('Tap or press Enter to continue', fw / 2, fh * 0.7);
    }
  };

  // ============================================================
  // SECTION 10: MENU SYSTEM
  // ============================================================
  const Menu = {
    state: 'title', selectedMode: null, selectedDuration: null,
    buttons: [], animFrame: 0, clickHandler: null, lobbyDots: 0,

    init() {
      this.state = 'title'; this.buttons = []; this.lobbyDots = 0;
      const params = new URLSearchParams(window.location.search);
      const room = params.get('room');
      if (room) {
        this.selectedMode = 'online'; this.state = 'lobby';
        Net.connect(room);
        Net.startCb = (dur) => { if (this.clickHandler) this.clickHandler('online_guest', dur); };
        Net.disconnectCb = () => { if (Game.state === 'MENU') { this.state = 'mode'; Net.disconnect(); } };
      }
    },

    buildButtons() {
      this.buttons = [];
      const fw = CONFIG.DESIGN_WIDTH, fh = CONFIG.DESIGN_HEIGHT;
      if (this.state === 'title') {
        this.buttons.push({ x: fw / 2 - 100, y: fh * 0.6, w: 200, h: 50, label: 'PLAY', value: 'play' });
      } else if (this.state === 'mode') {
        this.buttons.push({ x: fw / 2 - 130, y: fh * 0.33, w: 260, h: 50, label: 'VS COMPUTER', value: 'ai' });
        this.buttons.push({ x: fw / 2 - 130, y: fh * 0.48, w: 260, h: 50, label: 'LOCAL 2 PLAYER', value: 'local' });
        this.buttons.push({ x: fw / 2 - 130, y: fh * 0.63, w: 260, h: 50, label: 'ONLINE', value: 'online' });
      } else if (this.state === 'lobby') {
        if (Net.isHost && Net.oppConnected) {
          const durs = CONFIG.DURATIONS, bw = 70, bh = 50, gap = 15;
          const tw = durs.length * bw + (durs.length - 1) * gap, sx = fw / 2 - tw / 2;
          for (let i = 0; i < durs.length; i++) {
            this.buttons.push({ x: sx + i * (bw + gap), y: fh * 0.5, w: bw, h: bh,
              label: durs[i] + 'm', value: 'dur_' + durs[i], selected: this.selectedDuration === durs[i] });
          }
          this.buttons.push({ x: fw / 2 - 80, y: fh * 0.7, w: 160, h: 50, label: 'START!', value: 'online_start' });
        }
        this.buttons.push({ x: fw / 2 - 60, y: fh * 0.85, w: 120, h: 40, label: 'BACK', value: 'lobby_back' });
      } else if (this.state === 'duration') {
        const durs = CONFIG.DURATIONS, bw = 70, bh = 50, gap = 15;
        const tw = durs.length * bw + (durs.length - 1) * gap, sx = fw / 2 - tw / 2;
        for (let i = 0; i < durs.length; i++) {
          this.buttons.push({ x: sx + i * (bw + gap), y: fh * 0.45, w: bw, h: bh,
            label: durs[i] + 'm', value: 'dur_' + durs[i], selected: this.selectedDuration === durs[i] });
        }
        this.buttons.push({ x: fw / 2 - 80, y: fh * 0.65, w: 160, h: 50, label: 'START!', value: 'start' });
      }
    },

    handleClick(dx, dy) {
      for (const b of this.buttons) {
        if (dx >= b.x && dx <= b.x + b.w && dy >= b.y && dy <= b.y + b.h) {
          TG.haptic('select'); this.onButton(b.value); return true;
        }
      }
      if (this.state === 'title') { TG.haptic('select'); this.onButton('play'); return true; }
      return false;
    },

    onButton(val) {
      if (val === 'play') this.state = 'mode';
      else if (val === 'ai' || val === 'local') { this.selectedMode = val; this.state = 'duration'; this.selectedDuration = 2; }
      else if (val === 'online') {
        this.selectedMode = 'online'; this.selectedDuration = 2; this.state = 'lobby';
        const rid = Net.genRoomId(); Net.connect(rid);
        Net.oppJoinCb = () => { this.buildButtons(); };
        Net.startCb = null;
        Net.disconnectCb = () => { if (Game.state === 'MENU') { this.state = 'lobby'; this.buildButtons(); } };
      }
      else if (val === 'lobby_back') { Net.disconnect(); this.state = 'mode'; }
      else if (val === 'online_start') {
        if (this.selectedDuration && this.clickHandler && Net.oppConnected) {
          Net.sendStart(this.selectedDuration); this.clickHandler('online_host', this.selectedDuration);
        }
      }
      else if (val.startsWith('dur_')) this.selectedDuration = parseInt(val.split('_')[1]);
      else if (val === 'start') { if (this.selectedDuration && this.clickHandler) this.clickHandler(this.selectedMode, this.selectedDuration); }
      this.buildButtons();
    },

    render(ctx) {
      const fw = CONFIG.DESIGN_WIDTH, fh = CONFIG.DESIGN_HEIGHT;
      this.animFrame++;
      const g = ctx.createLinearGradient(0, 0, 0, fh);
      g.addColorStop(0, CONFIG.COL_MENU_BG); g.addColorStop(1, '#1b2838');
      ctx.fillStyle = g; ctx.fillRect(0, 0, fw, fh);
      ctx.fillStyle = CONFIG.COL_GROUND; ctx.fillRect(0, CONFIG.GROUND_Y, fw, fh - CONFIG.GROUND_Y);

      if (this.state === 'title') {
        ctx.font = 'bold 56px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = 'rgba(0,0,0,0.3)'; ctx.fillText('SLIME SOCCER', fw / 2 + 3, fh * 0.2 + 3);
        ctx.fillStyle = CONFIG.COL_MENU_ACCENT; ctx.fillText('SLIME SOCCER', fw / 2, fh * 0.2);
        const bob = Math.sin(this.animFrame * 0.05) * 5;
        ctx.fillStyle = CONFIG.COL_P1; ctx.beginPath(); ctx.arc(fw * 0.35, CONFIG.GROUND_Y + bob, 35, Math.PI, 0); ctx.closePath(); ctx.fill();
        ctx.fillStyle = CONFIG.COL_P2; ctx.beginPath(); ctx.arc(fw * 0.65, CONFIG.GROUND_Y - bob, 35, Math.PI, 0); ctx.closePath(); ctx.fill();
        ctx.fillStyle = CONFIG.COL_BALL; ctx.beginPath();
        ctx.arc(fw / 2, CONFIG.GROUND_Y - 60 + Math.sin(this.animFrame * 0.07 + 1) * 15, 12, 0, Math.PI * 2); ctx.fill();
        const blink = Math.sin(this.animFrame * 0.06) * 0.3 + 0.7;
        ctx.globalAlpha = blink; ctx.font = '18px monospace'; ctx.fillStyle = CONFIG.COL_TEXT;
        ctx.fillText('Tap or press Enter to start', fw / 2, fh * 0.8); ctx.globalAlpha = 1;
      } else if (this.state === 'mode') {
        ctx.font = 'bold 32px monospace'; ctx.textAlign = 'center'; ctx.fillStyle = CONFIG.COL_TEXT;
        ctx.fillText('SELECT MODE', fw / 2, fh * 0.18);
      } else if (this.state === 'lobby') {
        ctx.textAlign = 'center';
        if (!Net.connected) {
          ctx.font = 'bold 24px monospace'; ctx.fillStyle = CONFIG.COL_WARN;
          ctx.fillText('Connecting...', fw / 2, fh * 0.2);
        } else if (Net.isHost && !Net.oppConnected) {
          ctx.font = 'bold 24px monospace'; ctx.fillStyle = CONFIG.COL_MENU_ACCENT;
          ctx.fillText('WAITING FOR OPPONENT', fw / 2, fh * 0.15);
          ctx.font = 'bold 20px monospace'; ctx.fillStyle = CONFIG.COL_TEXT;
          ctx.fillText('Room: ' + Net.roomId, fw / 2, fh * 0.28);
          ctx.font = '14px monospace'; ctx.fillStyle = 'rgba(255,255,255,0.5)';
          ctx.fillText('Share this link:', fw / 2, fh * 0.38);
          ctx.fillStyle = CONFIG.COL_MENU_ACCENT; ctx.font = '12px monospace';
          ctx.fillText(location.origin + location.pathname + '?room=' + Net.roomId, fw / 2, fh * 0.43);
          this.lobbyDots = (this.lobbyDots + 1) % 120;
          ctx.font = '20px monospace'; ctx.fillStyle = 'rgba(255,255,255,0.4)';
          ctx.fillText('Waiting' + '.'.repeat(1 + Math.floor(this.lobbyDots / 30) % 4), fw / 2, fh * 0.55);
        } else if (Net.isHost && Net.oppConnected) {
          ctx.font = 'bold 24px monospace'; ctx.fillStyle = '#4caf50';
          ctx.fillText('OPPONENT CONNECTED!', fw / 2, fh * 0.15);
          ctx.font = 'bold 22px monospace'; ctx.fillStyle = CONFIG.COL_TEXT;
          ctx.fillText('SELECT DURATION', fw / 2, fh * 0.35);
        } else if (!Net.isHost) {
          if (Net.oppConnected) {
            ctx.font = 'bold 24px monospace'; ctx.fillStyle = '#4caf50'; ctx.fillText('CONNECTED!', fw / 2, fh * 0.2);
            this.lobbyDots = (this.lobbyDots + 1) % 120;
            ctx.font = '20px monospace'; ctx.fillStyle = 'rgba(255,255,255,0.5)';
            ctx.fillText('Waiting for host to start' + '.'.repeat(1 + Math.floor(this.lobbyDots / 30) % 4), fw / 2, fh * 0.4);
          } else {
            ctx.font = 'bold 24px monospace'; ctx.fillStyle = CONFIG.COL_MENU_ACCENT;
            ctx.fillText('JOINING ROOM...', fw / 2, fh * 0.3);
          }
        }
      } else if (this.state === 'duration') {
        ctx.font = 'bold 28px monospace'; ctx.textAlign = 'center'; ctx.fillStyle = CONFIG.COL_TEXT;
        ctx.fillText('MATCH DURATION', fw / 2, fh * 0.2);
        ctx.font = '16px monospace'; ctx.fillStyle = 'rgba(255,255,255,0.5)';
        ctx.fillText(this.selectedMode === 'ai' ? 'VS Computer' : 'Local 2 Player', fw / 2, fh * 0.32);
      }

      this.buildButtons();
      for (const b of this.buttons) {
        const sel = b.selected;
        ctx.fillStyle = sel ? CONFIG.COL_MENU_ACCENT : CONFIG.COL_MENU_BTN;
        ctx.beginPath(); ctx.roundRect(b.x, b.y, b.w, b.h, 8); ctx.fill();
        ctx.strokeStyle = sel ? CONFIG.COL_MENU_ACCENT : 'rgba(255,255,255,0.15)'; ctx.lineWidth = 2;
        ctx.beginPath(); ctx.roundRect(b.x, b.y, b.w, b.h, 8); ctx.stroke();
        ctx.font = 'bold 18px monospace'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle';
        ctx.fillStyle = sel ? '#000' : CONFIG.COL_TEXT; ctx.fillText(b.label, b.x + b.w / 2, b.y + b.h / 2);
      }
    }
  };

  // ============================================================
  // SECTION 11: GAME STATE MACHINE
  // ============================================================
  const Game = {
    state: 'MENU', mode: 'ai',
    s1: null, s2: null, ball: null, particles: [],
    timeLeft: 0, celebTimer: 0, lastScorer: 0, gameOverTimer: 0,
    netFrameCounter: 0, disconnectMsg: false,

    init() { this.state = 'MENU'; Menu.init(); Menu.clickHandler = (mode, dur) => this.startMatch(mode, dur); },

    startMatch(mode, durMin) {
      this.mode = mode; this.timeLeft = durMin * 60 * 60;
      this.s1 = new Slime(1, CONFIG.DESIGN_WIDTH * 0.25, CONFIG.COL_P1);
      this.s2 = new Slime(2, CONFIG.DESIGN_WIDTH * 0.75, CONFIG.COL_P2);
      this.resetBall(0); this.particles = []; this.state = 'PLAYING';
      this.netFrameCounter = 0; this.disconnectMsg = false;
      TG.haptic('notify', 'success');
      if (mode === 'online_host' || mode === 'online_guest') {
        Net.disconnectCb = () => { this.state = 'GAME_OVER'; this.gameOverTimer = 0; this.disconnectMsg = true; };
      }
    },

    resetBall(ls) {
      const fw = CONFIG.DESIGN_WIDTH;
      this.ball = new Ball(fw / 2, CONFIG.DESIGN_HEIGHT * 0.3);
      this.ball.vx = (Math.random() - 0.5) * 3; this.ball.vy = -1;
      if (ls === 1) this.ball.x = fw * 0.65; else if (ls === 2) this.ball.x = fw * 0.35;
    },

    resetPositions(sc) {
      this.s1.x = CONFIG.DESIGN_WIDTH * 0.25; this.s1.y = CONFIG.GROUND_Y; this.s1.vx = 0; this.s1.vy = 0; this.s1.onGround = true;
      this.s2.x = CONFIG.DESIGN_WIDTH * 0.75; this.s2.y = CONFIG.GROUND_Y; this.s2.vx = 0; this.s2.vy = 0; this.s2.onGround = true;
      this.resetBall(sc);
    },

    goalScored(sc) {
      if (sc === 1) this.s1.score++; else this.s2.score++;
      this.lastScorer = sc; this.celebTimer = CONFIG.CELEBRATION_FRAMES; this.state = 'GOAL_SCORED';
      TG.haptic('notify', 'success'); Render.doShake(18);
      const gx = sc === 1 ? CONFIG.GOAL_DEPTH : CONFIG.DESIGN_WIDTH - CONFIG.GOAL_DEPTH;
      const gy = CONFIG.GROUND_Y - CONFIG.GOAL_HEIGHT / 2;
      for (let i = 0; i < CONFIG.GOAL_PARTICLES; i++) this.particles.push(new Particle(gx, gy, sc === 1 ? CONFIG.COL_P1 : CONFIG.COL_P2));
    },

    update() {
      switch (this.state) {
        case 'MENU': break;
        case 'PLAYING': this.updatePlaying(); break;
        case 'GOAL_SCORED':
          if (this.mode === 'online_guest') { Net.sendInput(Input.p1); Net.applyState(this); }
          else {
            this.celebTimer--;
            if (this.celebTimer <= 0) { this.resetPositions(this.lastScorer); this.state = 'PLAYING'; }
            if (this.mode === 'online_host') Net.sendState(this);
          }
          this.updateParticles(); break;
        case 'GAME_OVER':
          this.gameOverTimer++;
          if (this.mode === 'online_host' && this.gameOverTimer === 1) Net.sendState(this);
          if (this.mode === 'online_guest') Net.applyState(this);
          this.updateParticles(); break;
      }
    },

    updatePlaying() {
      const fw = CONFIG.DESIGN_WIDTH;

      // ONLINE GUEST: no physics, just interpolate
      if (this.mode === 'online_guest') {
        Net.sendInput(Input.p1); Net.applyState(this); this.updateParticles(); return;
      }

      // Input
      const p1In = Input.p1;
      let p2In;
      if (this.mode === 'ai') p2In = AI.update(this.s2, this.ball, this.s1, fw);
      else if (this.mode === 'online_host') p2In = Net.lastOppInput;
      else p2In = Input.p2;

      this.s1.update(p1In); this.s2.update(p2In);
      this.resolveSlimeSlime();
      this.handleGrab(this.s1, p1In); this.handleGrab(this.s2, p2In);
      this.ball.update();

      if (!this.ball.grabbed) {
        if (Physics.ballTouchesSlime(this.ball, this.s1)) {
          Physics.resolveBallSlime(this.ball, this.s1); TG.haptic('impact', 'light');
          this.spawnHitFX(this.ball.x, this.ball.y, CONFIG.COL_P1);
        }
        if (Physics.ballTouchesSlime(this.ball, this.s2)) {
          Physics.resolveBallSlime(this.ball, this.s2); TG.haptic('impact', 'light');
          this.spawnHitFX(this.ball.x, this.ball.y, CONFIG.COL_P2);
        }
        Physics.resolveBallWalls(this.ball, fw, CONFIG.GROUND_Y);
        if (Physics.ballInGoal(this.ball, 'left', fw)) { this.goalScored(2); return; }
        if (Physics.ballInGoal(this.ball, 'right', fw)) { this.goalScored(1); return; }
      }

      if (Camping.update(this.s1, fw)) this.goalScored(2);
      if (Camping.update(this.s2, fw)) this.goalScored(1);

      if (this.mode === 'online_host') {
        this.netFrameCounter++;
        if (this.netFrameCounter >= CONFIG.NET_STATE_INTERVAL) { this.netFrameCounter = 0; Net.sendState(this); }
      }

      this.timeLeft--;
      if (this.timeLeft <= 0) {
        this.state = 'GAME_OVER'; this.gameOverTimer = 0;
        TG.haptic('notify', this.s1.score > this.s2.score ? 'success' : 'error');
      }
      this.updateParticles();
    },

    resolveSlimeSlime() {
      const dx = this.s2.x - this.s1.x, dy = this.s2.y - this.s1.y;
      const dist = Math.sqrt(dx * dx + dy * dy), min = this.s1.radius + this.s2.radius;
      if (dist < min && dist > 0) {
        const ov = min - dist, nx = dx / dist;
        this.s1.x -= nx * ov * 0.5; this.s2.x += nx * ov * 0.5;
      }
    },

    handleGrab(slime, input) {
      const ball = this.ball;
      if (input.grab && !ball.grabbed) {
        const dx = ball.x - slime.x, dy = ball.y - slime.y;
        const dist = Math.sqrt(dx * dx + dy * dy);
        if (dist <= slime.radius + ball.radius + CONFIG.GRAB_RANGE && ball.y <= slime.y) {
          ball.grabbed = true; ball.grabbedBy = slime;
          ball.grabAngle = Math.atan2(-(ball.y - slime.y), ball.x - slime.x);
          ball.grabAngle = Math.max(0.15, Math.min(Math.PI - 0.15, ball.grabAngle));
          slime.grabTimer = 0; TG.haptic('impact', 'medium');
        }
      }
      if (ball.grabbed && ball.grabbedBy === slime) {
        slime.grabTimer++;
        if (input.left) ball.grabAngle = Math.min(Math.PI - 0.15, ball.grabAngle + 0.04);
        if (input.right) ball.grabAngle = Math.max(0.15, ball.grabAngle - 0.04);
        if (!input.grab || slime.grabTimer >= CONFIG.GRAB_MAX_HOLD) {
          ball.doThrow(); slime.grabTimer = 0; TG.haptic('impact', 'heavy');
        }
      }
    },

    spawnHitFX(x, y, col) { for (let i = 0; i < CONFIG.HIT_PARTICLES; i++) this.particles.push(new Particle(x, y, col)); },

    updateParticles() {
      for (let i = this.particles.length - 1; i >= 0; i--) {
        this.particles[i].update(); if (!this.particles[i].alive) this.particles.splice(i, 1);
      }
    },

    handleDesignClick(dx, dy) {
      if (this.state === 'MENU') Menu.handleClick(dx, dy);
      else if (this.state === 'GAME_OVER' && this.gameOverTimer > 30) {
        Net.disconnect(); this.disconnectMsg = false; this.state = 'MENU'; Menu.init();
        if (window.history.replaceState) window.history.replaceState({}, '', location.pathname);
      }
    }
  };

  // ============================================================
  // SECTION 12: MAIN GAME LOOP
  // ============================================================
  const Loop = {
    lastTime: 0, accum: 0, dt: 1000 / 60,
    start() { this.lastTime = performance.now(); requestAnimationFrame(t => this.tick(t)); },
    tick(now) {
      const el = now - this.lastTime; this.lastTime = now;
      this.accum += Math.min(el, 100);
      while (this.accum >= this.dt) { Input.update(); Game.update(); this.accum -= this.dt; }
      this.render(); requestAnimationFrame(t => this.tick(t));
    },
    render() {
      Render.begin();
      switch (Game.state) {
        case 'MENU': Menu.render(Render.ctx); break;
        case 'PLAYING': case 'GOAL_SCORED':
          Render.drawBG(); Render.drawGoals();
          Render.drawSlime(Game.s1); Render.drawSlime(Game.s2);
          Render.drawBall(Game.ball); Render.drawGrabInd(Game.ball);
          Render.drawParticles(Game.particles);
          Render.drawHUD(Game.s1, Game.s2, Game.timeLeft);
          if (Game.state === 'GOAL_SCORED') Render.drawGoalText(Game.lastScorer, Game.celebTimer);
          break;
        case 'GAME_OVER':
          Render.drawBG(); Render.drawGoals();
          Render.drawSlime(Game.s1); Render.drawSlime(Game.s2);
          Render.drawBall(Game.ball); Render.drawParticles(Game.particles);
          Render.drawHUD(Game.s1, Game.s2, 0);
          Render.drawGameOver(Game.s1, Game.s2, Game.disconnectMsg);
          break;
      }
      Render.end();
      if (Input.isMobile && (Game.state === 'PLAYING' || Game.state === 'GOAL_SCORED')) {
        const c = Render.ctx; c.save();
        const dpr = Math.min(window.devicePixelRatio || 1, 2);
        c.scale(dpr, dpr); Input.renderTouch(c, window.innerWidth, window.innerHeight); c.restore();
      }
    }
  };

  // ============================================================
  // SECTION 13: INITIALIZATION
  // ============================================================
  (function boot() {
    TG.init();
    const canvas = document.getElementById('gameCanvas');
    Render.init(canvas); Input.init(canvas); Game.init();

    function handlePointer(e) {
      const rect = canvas.getBoundingClientRect();
      let cx, cy;
      if (e.touches) { cx = e.touches[0].clientX - rect.left; cy = e.touches[0].clientY - rect.top; }
      else { cx = e.clientX - rect.left; cy = e.clientY - rect.top; }
      const dpr = Math.min(window.devicePixelRatio || 1, 2);
      Game.handleDesignClick((cx * dpr - Render.ox) / Render.scale, (cy * dpr - Render.oy) / Render.scale);
    }

    canvas.addEventListener('click', handlePointer);
    canvas.addEventListener('touchstart', (e) => {
      if (Game.state === 'MENU' || Game.state === 'GAME_OVER') handlePointer(e);
    }, { passive: true });

    window.addEventListener('keydown', (e) => {
      if (Game.state === 'MENU') {
        if (e.code === 'Enter' || e.code === 'Space') {
          if (Menu.state === 'title') Menu.onButton('play');
          else if (Menu.state === 'duration' && Menu.selectedDuration) Menu.onButton('start');
        }
        if (Menu.state === 'mode') {
          if (e.code === 'Digit1' || e.code === 'Numpad1') Menu.onButton('ai');
          if (e.code === 'Digit2' || e.code === 'Numpad2') Menu.onButton('local');
          if (e.code === 'Digit3' || e.code === 'Numpad3') Menu.onButton('online');
        }
        if (Menu.state === 'lobby') {
          if ((e.code === 'Enter' || e.code === 'Space') && Net.isHost && Net.oppConnected && Menu.selectedDuration) Menu.onButton('online_start');
          if (e.code === 'Escape') Menu.onButton('lobby_back');
          const durs = CONFIG.DURATIONS;
          for (let i = 0; i < durs.length; i++) {
            if (e.code === 'Digit' + (i + 1) || e.code === 'Numpad' + (i + 1)) { Menu.selectedDuration = durs[i]; Menu.buildButtons(); }
          }
        }
        if (Menu.state === 'duration') {
          const durs = CONFIG.DURATIONS;
          for (let i = 0; i < durs.length; i++) {
            if (e.code === 'Digit' + (i + 1) || e.code === 'Numpad' + (i + 1)) { Menu.selectedDuration = durs[i]; Menu.buildButtons(); }
          }
        }
      } else if (Game.state === 'GAME_OVER' && Game.gameOverTimer > 30) {
        if (e.code === 'Enter' || e.code === 'Space') {
          Net.disconnect(); Game.disconnectMsg = false; Game.state = 'MENU'; Menu.init();
          if (window.history.replaceState) window.history.replaceState({}, '', location.pathname);
        }
      }
    });

    window.addEventListener('resize', () => Render.resize());
    window.addEventListener('orientationchange', () => setTimeout(() => Render.resize(), 100));
    Loop.start();
  })();

  </script>
</body>
</html>
